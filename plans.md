# From TOP

1. Application should have at least two routes (I.E. individual Route components that the router picks between)

2. Decide:
    - Component and folder structure
    - How to set up the application
    - Which components/functionalities are needed

3. Have at least the following pages:
    - A homepage
    - A shop page, which includes the shopping cart

4. Let a user navigate between the pages with a navigation bar, shown on both routes
    - The 'Router' Lesson of TOP is pertinent to routing (funnily enough): https://www.theodinproject.com/lessons/node-path-javascript-router
    - Assignment 3 in the aforementioned lesson is particular pertinent to the navigation bar, just remember the implementation is an older Router version: https://www.youtube.com/watch?v=Law7wfdg_ls

5. Add a few images or information to the homepage, anything basic

6. On the shopping cart route:
    i) User should see a sticky bar (it can just be a top section) displaying the number of items in the cart
    ii) Have a button next to "it" to go to the cart checkout and pay (NOT to be implemented)

7. Build card items in the SHOP for each product, featuring:
    i) An input for user to select how many items to buy
    ii) A button for incrementing the aforementioned quantity
    ii) A button for decrementing the aforementioned quantity
    iii) A title for each product
    iv) An "Add To Card" button

8. Number of items in the cart should adjust when something is added to the cart

9. Test app thoroughly:
    - Via React Testing Library
    - Don't directly test react-router-dom

# DONE Plan of static version of app

- App component:
    -- DONE Renders a ShoppingCartSite component, passing to it the following props:
        -- An availableItemNames array (containing strings with item names)

- ShoppingCartSite component:
    -- DONE Renders a RouteSwitcher component, passing to it the following props:
        -- props.availableItemNames

- RouteSwitcher component:
    -- DONE Imports Home and Shop

    -- DONE Renders the following in between BrowserRouter component tags:

        -- A NavigationBar component, passing to it the following props:
            -- path strings array, ['home', 'shop']

        -- In between Routes component tags:
            -- DONE A Route for the Home component, passing to it the following props:
                -- websiteType (which in this case will be 'shopping')
                -- The imageSrc for an image (in this case, an image related to shopping)

            -- DONE A Route for the Shop component, passing to it the following props:
                -- props.availableItemNames

    -- DONE Add TODO re: passing to navigationBar and the Routes similar information, adn so passing from same object literal to avoid, essentially, repeating code

- NavigationBar component:
    -- DONE Renders a ul element containing, for each displayName in its props:
        -- A li element with this displayName as text content
        -- Links to the corresponding Route (see https://blog.devgenius.io/how-to-create-a-navbar-using-react-router-51b78bc6ce51 for a Router Version 6 example)

- Home component:
    -- DONE Renders a div containing:
        -- A div with the text content 'Welcome to my {props.websiteType} website!'
        -- An img with the src props.imageSrc

- Shop component:
    -- Renders a div containing:
        -- DONE A CartTracker component
        -- DONE An ItemList component, passing to it props.availableItemNames

- CartTracker component:
    -- DONE Renders a div containing:
        -- DONE A CartSizeDisplay component
        -- DONE A CheckoutButton component

- CartSizeDisplay component:
    -- DONE Renders a div with text content '{} items in cart!'

- CheckoutButton component:
    -- DONE Renders a button with text content 'Pay'

- ItemList component:
    -- Renders, in a div:
        -- DONE An ItemCard component for each element in props.availableItemNames, supplying the corresponding name (itemName) to the ItemCard in props


- ItemCard component:
    -- Renders a div containing:
        -- DONE Text content of '{props.itemName}'
        -- DONE Rendered QuantityInput component

- QuantityInput component:
    -- Renders a div containing:
        -- DONE A label element with a htmlFor of the same ID generated for the input below
        -- DONE An input of type number with a min of 0 and steps of 1 and a default initial value (later to be replaced by state) and an ID generated by uniqid

# DONE Plan of interactive version of app

States:

    - allQuantitiesChosen:
        Affects:
            - Text content of CartSizeDisplay (the sum of allQuantitiesChosen should be included in the text content)
            - Value of corresponding input in QuantityInput (this input is linked to via the index in allQuantitiesChosen being the key of the QuantityInput's parent ItemCard)
        Affected by:
            - Changing value of input in QuantityInput (should deep-copy allQuantitiesChosen, change the element at the correct index of the deep copy, then update allQuantitiesChosen using setAllQuantitiesChosen)

Step-by-step plan:

1. DONE In App, change availableItemNames to availableItems, which will be an array containing, for each item, an object literal featuring a key-value pair for the item's name (a string)
2. DONE Make the rest of the src directory consistent with the aforementioned new format

3. DONE In App, to each object literal in availableItems, add a key-value pair for initialQuantityChosen

4. DONE In Shop, map initialQuantityChosen from each item object in availableItems to its corresponding index in a new array allInitialQuantitiesChosen
5. DONE In Shop, initialize state of allQuantitiesChosen (as allInitialQuantitiesChosen) and setAllQuantitiesChosen, with the assistance of useState

6. DONE In Shop, get sum of allQuantitiesChosen (call it cartSize) via the array's reduce method
7. DONE Pass cartSize down to CartSizeDisplay via props
8. DONE Render cartSize in CartSizeDisplay's text content

9. DONE In Shop, map availableItems to an array of availableItemNames and pass it to ItemList via props

10. DONE Pass allQuantitiesChosen from Shop to ItemList via props
11. DONE Pass setAllQuantitiesChosen from Shop to QuantityInput via props

12. DONE Pass each item's name in availableItemNames from ItemList to each ItemCard via props
13. DONE Pass an item's corresponding quantityChosen in allQuantitiesChosen from the ItemList down to the QuantityInput via props

14. DONE In QuantityInput, set the input's value to quantityChosen

15. DONE Think about error handling regarding an initialQuantityChosen passed into ShoppingCartSite being negative or non-integer, for example

# Plan of test suites

Going to take a bottom-up approach to testing (I.E. starting with the deepest components) so that I can warm-up without needing extra features to write a test suite such as mocking child components.

First, I am going to use https://docs.google.com/document/d/1icLdWxKegSnLFl1VmbX_v4pA0MaWB-CaaBLToOJ5PyI/edit to decide what, in each component, must be tested. The exact details of how this will be done will not be planned fully yet--will do that just before writing each test suite.

1. Home:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of a Home component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by Home
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:
            - Make assertions about said side-effects (the rendering)

2. QuantityInput:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of a QuantityInput component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by QuantityInput
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:
            - Make assertions about said side-effects (the rendering)

    - Outgoing command messages:
        - Specific:
            - Input's onChange event, as it should call the handleChange method, which may or may not call a method, forQuantityChosenChange, that mutates data (allQuantitiesChosen in Shop) outside of QuantityInput (don't worry about testing the re-rendering of QuantityInput as a result
        - Method of testing:
            - Assert whether or not the message gets sent, probably using mocking

3. ItemCard:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of an ItemCard component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by ItemCard
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:         
            - Make assertions about said side-effects (the rendering)
            - Will have to mock child QuantityInput component

4. ItemList:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of an ItemList component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by ItemList
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:         
            - Make assertions about said side-effects (the rendering)
            - Will have to mock child ItemCard components

5. CartSizeDisplay:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of an CartSizeDisplay component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by CartSizeDisplay
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:         
            - Make assertions about said side-effects (the rendering)

6. CheckoutButton:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of an CheckoutButton component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by CheckoutButton
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:         
            - Make assertions about said side-effects (the rendering)

7. CartTracker:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of an CartTracker component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by CartTracker
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:         
            - Make assertions about said side-effects (the rendering)
            - Will have to mock child CartSizeDisplay component
            - Will have to mock child CheckoutButton component

8. Shop:

    - Incoming command messages effects with direct, public side-effects:
        - Specifics:

            - Specific:
                - Essentially, the creation of an Shop component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by Shop
                - Make sure specific input props lead to the correct output (child) props
                - N.B.: not entirely sure if this fits the above definition but I think it works for now
            - Method of testing:         
                - Make assertions about said side-effects (the rendering)
                - Will have to mock child CartTracker component
                - Will have to mock child ItemList component

            - Specific:
                - Another incoming command message is a call to modifyQuantityChosen (from, for example, a deeper-down QuantityInput component); this should have the effect of changing the state allQuantitiesChosen, which is in the highest level of the same Shop component (so this is a direct side-effect) and allQuantitiesChosen is passed down to child components, meaning it can be thought of as public
            - Method of testing:
                - Make assertions about said side-effects (allQuantitiesChosen)


9. NavigationBar:

    - Incoming command messages effects with direct, public side-effects:
        - Specific:
            - Essentially, the creation of an NavigationBar component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by NavigationBar
            - Make sure specific input props lead to the correct output (child) props
            - N.B.: not entirely sure if this fits the above definition but I think it works for now
        - Method of testing:         
            - Make assertions about said side-effects (the rendering)

    - Outgoing command messages:
        - Specific:
            - Whatever outgoing command clicking on a Link results in
        - Method of testing:
            - Assert whether or not the message gets sent, probably using mocking

10. RouteSwitcher:

    - Incoming command messages effects with direct, public side-effects:
        - Specifics:

            - Specific:
                - Essentially, the creation of a RouteSwitcher component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by RouteSwitcher
                - Make sure specific input props lead to the correct output (child) props
                - N.B.: not entirely sure if this fits the above definition but I think it works for now
            - Method of testing:         
                - Make assertions about said side-effects (the rendering)
                - May or may not have to mock BrowserRouter, Routes and Route components
                - May have to mock child Home component
                - May have to mock child Home component
                - May have to mock child Shop component

            - Specific:
                - Another incoming command message is to switch between Routes (command from NavigationBar), which would have the result of rendering one Route as opposed to another (a direct, public side effect)
            - Method of testing:
                - Make assertions about said side-effects (one Route being rendered as opposed to another when whatever event callback etc. comes back from the NavigationBar)

11. ShoppingCart:

    - Incoming command messages effects with direct, public side-effects:
        - Specifics:

            - Specific:
                - Essentially, the creation of a ShoppingCart component should cause the rendering of what's in its return statement, this rendering being a public side-effect that is directly resulted by ShoppingCart
                - Make sure specific input props lead to the correct output (child) props
                - N.B.: not entirely sure if this fits the above definition but I think it works for now
            - Method of testing:         
                - Make assertions about said side-effects (the rendering)
                - Will have to mock child RouteSwitcher component

            - Specific:
                - If the ShoppingCart is supplied availableItems in which any initialChosenQuantity is non-integer or below 0, an error should be thrown
            - Method of testing:
                - Make assertions about said side-effects (ensure an error is thrown with the correct message)

12. App:

    - I don't think this needs to be tested